<!DOCTYPE html>
<head>
    <title>Canvas Render</title>
    <style>
        body {
            background-color: rgba(0, 0, 0, 0.5);
            margin: 0px;
            overflow: hidden;
        }
        #sites {
        }
        .site {
            width: 800px;
            height: 300px;
            display: inline-block;
            text-align: center; /* center horizontally */
            vertical-align: middle; /* center vertically */
        }
    </style>
</head>
<body>
    <div id="sites"></div>

    <script src='/js/bundle/three.min.js'></script>
    <script src='/js/gridfs.js'></script>
    <script>

function ij(lon, lat, w, h) {
        var ii = Math.floor(((90 - lat) / 180 * h) % h);
        var jj = Math.floor((lon / 360 * w) % w);
        return {i: ii, j: jj};
}

function levelRadius(level) {
    return 1000 + level * 2000;
}

function patchGuru (level, num, index, url) {
  var r = levelRadius(level);
    var u = url.split('.')[0] + '-L' + level + '-' + index + '.' + url.split('.')[1];
    var n = Math.sqrt(num/2);
    var p = t = Math.PI / n;
    var p0 = index % (2*n);
    var t0 = (index-p0)/(2*n);
    
    var geometry = new THREE.SphereGeometry( r, 1, 1,  p0/(2*n)*2*Math.PI, p, t0/n*Math.PI, t);
    geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );
    var material = new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( u ) } );
    material.side = THREE.DoubleSide;
    scene.add( new THREE.Mesh( geometry, material ) );
    console.log({ size: 2*n+'x'+n, radius: r, url: u, phiStart: p0, phiLength: p, thetaStart: t0, thetaLength: t });
}

function patch (level, i, j, url) {
  var r = levelRadius(level);
    var p = t = Math.PI / tiles[level].hs;
    var p0 = (i % tiles[level].ws)/tiles[level].ws * 2 * Math.PI;
    var t0 = (j % tiles[level].hs)/tiles[level].hs * Math.PI;
    
    var geometry = new THREE.SphereGeometry( r, 1, 1,  p0, p, t0, t);
    geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );
    var material = new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( url ) } );
    material.side = THREE.DoubleSide;
    scene.add( new THREE.Mesh( geometry, material ) );
}

function patchn(level) {
  var n = config.levels[level];
  if (typeof n === 'undefined') {
    return;
  }
  var h = Math.round(Math.sqrt(n/2));
  var w = 2 * h;
  var IJ = ij(lon, lat, w, h);
  patch(level, n, IJ.i*w+IJ.j, img);
}

function patchLIJ(level, i, j) {

}

var img = '/gridfs/panolib.jpg';
var config = {
    "mode": "default",
    "levels": [
        512,
        128,
        32,
        8
    ]
};

var tiles = [];
for (var i = 0; i < config.levels.length; i++) {
  tiles[i] = {};
  tiles[i].hs = Math.round(Math.sqrt(config.levels[i]/2));
  tiles[i].ws = tiles[i].hs * 2;
  tiles[i].ts = [];
  for (var j = 0; j < config.levels[i]; j++) {
    tiles[i].ts[j] = 0;
  }
}

function getTile(level, i, j) {
  return tiles[level].ts[i*tiles[level].ws+j];
}

function setTile(level, i, j, value) {
  tiles[level].ts[i*tiles[level].ws+j] = value;
}

var sites = document.getElementById('sites');
var canvas = document.createElement('div');
canvas.className = "site";
sites.appendChild(canvas);

var WIDTH = canvas.clientWidth;
var HEIGHT = canvas.clientHeight;

var inScope = false,
    isUserInteracting = false,
    onMouseDownMouseX = 0, onMouseDownMouseY = 0,
    lon = 0, onMouseDownLon = 0,
    lat = 0, onMouseDownLat = 0,
    phi = 0, theta = 0;

canvas.style.position = 'relative';
var loc = document.createElement('div');
loc.style.position = "absolute";
loc.style.bottom = "1px";
loc.style.right = "1px";
loc.style.textAlign = "right";
loc.style.opacity = "0.8";
loc.style.width = "32px";
loc.style.height = "32px";
loc.tag = 'hidden';
canvas.appendChild(loc);

var renderer = new THREE.WebGLRenderer({ antialias : true, alpha: true });
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setClearColor(new THREE.Color('lightgrey'), 0.5);
renderer.setSize( WIDTH, HEIGHT);
// renderer.domElement.style.position = "relative";
renderer.autoClear = false;
canvas.appendChild( renderer.domElement );

// init scene and camera
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(45, 0.5 * WIDTH/HEIGHT,  1, 10000);
camera.target = new THREE.Vector3( 0, 0, 0 );
var camHelper = new THREE.CameraHelper( camera );
scene.add( camHelper );

var outsider = new THREE.PerspectiveCamera(95, 0.5 * WIDTH/HEIGHT, 0.01, 1000000);
outsider.lookAt(scene.position);
outsider.position.set(0, 0, 20000);

var mesh = [];
scene.add(mesh[1]);

// listeners
canvas.addEventListener('resize', function(){
        WIDTH = canvas.clientWidth;
        HEIGHT = canvas.clientHeight;
        renderer.setSize( WIDTH, HEIGHT );
        camera.aspect	= 0.5 * WIDTH/HEIGHT;
        camera.updateProjectionMatrix();		
        outsider.aspect	= 0.5 * WIDTH/HEIGHT;
        outsider.updateProjectionMatrix();		
        }, false);

canvas.addEventListener( 'mouseenter', function(event){
        inScope = true;
        isUserInteracting = false;
        }, false );

canvas.addEventListener( 'mouseleave', function(event){
        inScope = false;
        isUserInteracting = false;
        }, false );

canvas.addEventListener( 'mousemove', function(event){
        if (!inScope) { return; }
        if ( isUserInteracting === true ) {
        lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
        lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
        }        
        }, false );

canvas.addEventListener( 'mousedown', function(event){
        if (!inScope) { return; }
        event.preventDefault();
        isUserInteracting = true;
        onPointerDownPointerX = event.clientX;
        onPointerDownPointerY = event.clientY;
        onPointerDownLon = lon;
        onPointerDownLat = lat;
        }, false );

canvas.addEventListener( 'mouseup', function(event){
        if (!inScope) { return; }
        isUserInteracting = false;
        }, false );

function onDocumentMouseWheel( event ) {
    if (!inScope) { return; }
    if ( event.wheelDeltaY ) {
        camera.fov -= event.wheelDeltaY * 0.05;
    } else if ( event.wheelDelta ) {
        camera.fov -= event.wheelDelta * 0.05;
    } else if ( event.detail ) {
        camera.fov += event.detail * 1.0;
    }
    // narrowing
    if (camera.fov <   5) { camera.fov =   5; }
    if (camera.fov > 125) { camera.fov = 125; }
    camera.updateProjectionMatrix();
}

canvas.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
canvas.addEventListener( 'DOMMouseScroll', onDocumentMouseWheel, false);

animate();

// render the scene
function animate() {
    requestAnimationFrame( animate );
    render();
}

function render() {

    if (lon <  0 ) { lon += 360; }
    if (lon > 360) { lon -= 360; }
    lat = Math.max( - 85, Math.min( 85, lat ) );
    loc.innerHTML = lon.toFixed(0) + '<br />' + lat.toFixed(0);

    // lon,lat (in degree) ==> phi, theta (in radian)
    phi = THREE.Math.degToRad( lon );
    theta = THREE.Math.degToRad( 90 - lat );
    camera.target.x = 500 * Math.sin( theta ) * Math.cos( phi );
    camera.target.y = 500 * Math.cos( theta );
    camera.target.z = 500 * Math.sin( theta ) * Math.sin( phi );
    camera.lookAt( camera.target );

    renderer.clear();
    camHelper.visible = true;
    renderer.setViewport( 0, 0, WIDTH/2, HEIGHT );
    renderer.render( scene, outsider );
    camHelper.visible = false;
    renderer.setViewport( WIDTH/2, 0, WIDTH/2, HEIGHT );
    renderer.render( scene, camera );
}

var tasks = [];
//        512, 128, 32, 8
tasks.push(function() { patch(2, 8, 0, '/gridfs/libpano.jpg'); });
tasks.push(function() { patch(2, 8, 1, '/gridfs/libpano.jpg'); });
tasks.push(function() { patch(2, 8, 4, '/gridfs/libpano.jpg'); });
tasks.push(function() { patch(2, 8, 5, '/gridfs/libpano.jpg'); });
tasks.push(function() { patch(1, 32, 4, '/gridfs/libpano.jpg'); });
tasks.push(function() { patch(1, 32, 4, '/gridfs/libpano.jpg'); });
tasks.push(function() { patch(2, 8, 4, '/gridfs/libpano.jpg'); });
tasks.push(function() { patch(2, 8, 4, '/gridfs/libpano.jpg'); });

// tasks.forEach( function(task){ task(); } );

    </script>
</body>
