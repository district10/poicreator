<!DOCTYPE html>
<head>
    <title>Canvas Render</title>
    <style>
        body {
            background-color: rgba(0, 0, 0, 0.5);
            margin: 0px;
            overflow: hidden;
        }
        #sites {
        }
        .site {
            width: 800px;
            height: 300px;
            display: inline-block;
            text-align: center; /* center horizontally */
            vertical-align: middle; /* center vertically */
        }
    </style>
</head>
<body>
    <div id="sites"></div>

    <script src='/js/bundle/three.min.js'></script>
    <script src='/js/gridfs.js'></script>
    <script>

function ij(lon, lat, w, h) {
        var ii = Math.floor((lon / 360 * w) % w);
        var jj = Math.floor(((90 - lat) / 180 * h) % h);
        return {i: ii, j: jj};
}

function patch (level, num, index, url) {
    var r = 500 + level * 100; // level: 0, 1, 2, ...
    var u = url.split('.')[0] + '-L' + level + '-' + index + '.' + url.split('.')[1];
    var n = Math.sqrt(num/2);
    var p = t = Math.PI / n;
    var p0 = index % (2*n);
    var t0 = (index-p0)/(2*n);
    
    var geometry = new THREE.SphereGeometry( r, 1, 1,  p0/(2*n)*2*Math.PI, p, t0/n*Math.PI, t);
    geometry.applyMatrix( new THREE.Matrix4().makeScale( -1, 1, 1 ) );
    var material = new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( u ) } );
    scene.add( new THREE.Mesh( geometry, material ) );
    console.log({ size: 2*n+'x'+n, radius: r, url: u, phiStart: p0, phiLength: p, thetaStart: t0, thetaLength: t });
}

var i, j;

var c = 0;
var colors = [ 
    "#007cdc", 
    "#887ddd", 
    "#ff5675", 
    "#ff8345", 
    "#8cc540", 
    "#009f5d", 
    "#d1d2d4" ];

var config = {
    "mode": "default",
    "levels": [
        512,
        128,
        32,
        8
    ]
};

var img = 'libpano.jpg';

var sites = document.getElementById('sites');
var canvas = document.createElement('div');
canvas.className = "site";
sites.appendChild(canvas);

var WIDTH = canvas.clientWidth;
var HEIGHT = canvas.clientHeight;

var inScope = false,
    isUserInteracting = false,
    onMouseDownMouseX = 0, onMouseDownMouseY = 0,
    lon = 0, onMouseDownLon = 0,
    lat = 0, onMouseDownLat = 0,
    phi = 0, theta = 0;

canvas.style.position = 'relative';
var loc = document.createElement('div');
loc.style.position = "absolute";
loc.style.bottom = "1px";
loc.style.right = "1px";
loc.style.textAlign = "right";
loc.style.opacity = "0.8";
loc.style.width = "32px";
loc.style.height = "32px";
loc.tag = 'hidden';
canvas.appendChild(loc);

var renderer = new THREE.WebGLRenderer({ antialias : true });
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setClearColor(new THREE.Color('lightgrey'), 0.5);
renderer.setSize( WIDTH, HEIGHT);
// renderer.domElement.style.position = "relative";
renderer.autoClear = false;
canvas.appendChild( renderer.domElement );

// init scene and camera
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(45, 0.5 * WIDTH/HEIGHT,  0.01, 2000);
camera.target = new THREE.Vector3( 0, 0, 0 );
var camHelper = new THREE.CameraHelper( camera );
scene.add( camHelper );

var outsider = new THREE.PerspectiveCamera(95, 0.5 * WIDTH/HEIGHT, 0.01, 1000000);
outsider.lookAt(scene.position);
outsider.position.set(0, 0, 2000);

var mesh = [];
//mesh[0] =  new THREE.Mesh( new THREE.SphereGeometry( 1500,  6,  4 ), new THREE.MeshBasicMaterial( { color: 0x007cdc, wireframe: true } ) );
mesh[1] =  new THREE.Mesh( new THREE.SphereGeometry( 1400, 12,  8 ), new THREE.MeshBasicMaterial( { color: 0x887ddd, wireframe: true } ) );
//mesh[3] =  new THREE.Mesh( new THREE.SphereGeometry( 1200, 64, 32 ), new THREE.MeshBasicMaterial( { color: 0xff8345, wireframe: true } ) );
//mesh[4] =  new THREE.Mesh( new THREE.SphereGeometry( 1100,128, 64 ), new THREE.MeshBasicMaterial( { color: 0x8cc540, wireframe: true } ) );
//mesh[5] =  new THREE.Mesh( new THREE.SphereGeometry(  150,256,128 ), new THREE.MeshBasicMaterial( { color: 0x009f5d, wireframe: true } ) );
//scene.add(mesh[0]);
scene.add(mesh[1]);
//scene.add(mesh[2]);
//scene.add(mesh[3]);
//scene.add(mesh[4]);
//scene.add(mesh[5]);

// listeners
canvas.addEventListener('resize', function(){
        WIDTH = canvas.clientWidth;
        HEIGHT = canvas.clientHeight;
        renderer.setSize( WIDTH, HEIGHT );
        camera.aspect	= 0.5 * WIDTH/HEIGHT;
        camera.updateProjectionMatrix();		
        outsider.aspect	= 0.5 * WIDTH/HEIGHT;
        outsider.updateProjectionMatrix();		
        }, false);

canvas.addEventListener( 'mouseenter', function(event){
        inScope = true;
        isUserInteracting = false;
        }, false );

canvas.addEventListener( 'mouseleave', function(event){
        inScope = false;
        isUserInteracting = false;
        }, false );

canvas.addEventListener( 'mousemove', function(event){
        if (!inScope) { return; }
        if ( isUserInteracting === true ) {
        lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
        lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
        }        
        }, false );

canvas.addEventListener( 'mousedown', function(event){
        if (!inScope) { return; }
        event.preventDefault();
        isUserInteracting = true;
        onPointerDownPointerX = event.clientX;
        onPointerDownPointerY = event.clientY;
        onPointerDownLon = lon;
        onPointerDownLat = lat;
        }, false );

canvas.addEventListener( 'mouseup', function(event){
        if (!inScope) { return; }
        isUserInteracting = false;
        }, false );

function onDocumentMouseWheel( event ) {
    if (!inScope) { return; }
    if ( event.wheelDeltaY ) {
        camera.fov -= event.wheelDeltaY * 0.05;
    } else if ( event.wheelDelta ) {
        camera.fov -= event.wheelDelta * 0.05;
    } else if ( event.detail ) {
        camera.fov += event.detail * 1.0;
    }
    // narrowing
    if (camera.fov <   5) { camera.fov =   5; }
    if (camera.fov > 125) { camera.fov = 125; }
    camera.updateProjectionMatrix();
}

canvas.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
canvas.addEventListener( 'DOMMouseScroll', onDocumentMouseWheel, false);

animate();

// render the scene
function animate() {
    requestAnimationFrame( animate );
    render();
}

function render() {

    if (lon <  0 ) { lon += 360; }
    if (lon > 360) { lon -= 360; }
    lat = Math.max( - 85, Math.min( 85, lat ) );
    loc.innerHTML = lon.toFixed(0) + '<br />' + lat.toFixed(0);

    var IJ = ij(lon, lat, 8, 4);
    if (IJ.i !== i || IJ.j !==j ) {
        i = IJ.i;
        j = IJ.j;
        console.log({i: i, j: j});
    }

    // lon,lat (in degree) ==> phi, theta (in radian)
    phi = THREE.Math.degToRad( lon );
    theta = THREE.Math.degToRad( 90 - lat );
    camera.target.x = 500 * Math.sin( theta ) * Math.cos( phi );
    camera.target.y = 500 * Math.cos( theta );
    camera.target.z = 500 * Math.sin( theta ) * Math.sin( phi );
    camera.lookAt( camera.target );

    renderer.clear();
    camHelper.visible = true;
    renderer.setViewport( 0, 0, WIDTH/2, HEIGHT );
    renderer.render( scene, outsider );
    camHelper.visible = false;
    renderer.setViewport( WIDTH/2, 0, WIDTH/2, HEIGHT );
    renderer.render( scene, camera );
}

var tasks = [];
tasks.push(function() { patch(2, 8, 0, '/gridfs/libpano.jpg'); });
tasks.push(function() { patch(2, 8, 1, '/gridfs/libpano.jpg'); });
tasks.push(function() { patch(2, 8, 2, '/gridfs/libpano.jpg'); });
tasks.push(function() { patch(2, 8, 3, '/gridfs/libpano.jpg'); });
tasks.push(function() { patch(2, 8, 4, '/gridfs/libpano.jpg'); });

// tasks.forEach( function(task){ task(); } );

    </script>
</body>
