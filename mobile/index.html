<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - controls - deviceorientation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="user-scalable=no, initial-scale=1">
    <style>
        body {
            margin: 0px;
            overflow: hidden;
        }
        .main{
            position: absolute;
            left: 0px;
            top: 0px;
            width: 450px;
            height: 450px;
            margin: 0 auto;
            overflow: hidden;
            z-index: 1000;
            opacity: 0.2;
        }
        .main:hover {
            opacity: 1.0;
        }
    </style>
</head>
<body>

<div class="main"><img class="absolute" src="qr.png" alt="" /></div>
<div id="container"></div>

<script src="jquery.min.js"></script>
<script src="three.min.js"></script>
<script src="DeviceOrientationControls.js"></script>

<script>
    "use strict";

    var isDesktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);
    var textures = [
        "texture.jpg",
        "2048x1024_HDPano_00000001.jpg",
        "512x256_HDPano_00000001.jpg",
    ];
    textures.forEach(function(t) {
        $('select#textures').append(new Option(t, t, true, true));
    });

    var container, camera, scene, renderer, controls, geometry, mesh;
    var isUserInteracting = false;
    var lon = 0, lat = 0, phi = 0, theta = 0;
    var onPointerDownPointerX = 0, onPointerDownPointerY = 0, onPointerDownLon = 0, onPointerDownLat = 0;

    window.addEventListener('load', function() {

        var animate = function(){

            window.requestAnimationFrame( animate );

            controls.update();

            if (isDesktop) {
                lat = Math.max( - 85, Math.min( 85, lat ) );
                phi = THREE.Math.degToRad( 90 - lat );
                theta = THREE.Math.degToRad( lon );
                camera.target.x = 500 * Math.sin( phi ) * Math.cos( theta );
                camera.target.y = 500 * Math.cos( phi );
                camera.target.z = 500 * Math.sin( phi ) * Math.sin( theta );
                camera.lookAt( camera.target );
            }

            renderer.render(scene, camera);

        };

        container = document.getElementById( 'container' );

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);
        camera.target = new THREE.Vector3( 0, 0, 0 );

        controls = new THREE.DeviceOrientationControls( camera );

        scene = new THREE.Scene();

        var geometry = new THREE.SphereGeometry( 500, 16, 8 );
        geometry.scale( - 1, 1, 1 );

        var material = new THREE.MeshBasicMaterial( {
            map: new THREE.TextureLoader().load( 'texture.jpg' )
        } );

        var mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );

        var geometry = new THREE.BoxGeometry( 100, 100, 100, 4, 4, 4 );
        var material = new THREE.MeshBasicMaterial( { color: 0xff00ff, side: THREE.BackSide, wireframe: true } );
        var mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = 0;
        container.appendChild(renderer.domElement);

        window.addEventListener('resize', function() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );

        }, false);

        animate();

        container.addEventListener( 'mousedown', function(event) {
            event.preventDefault();
            isUserInteracting = true;
            onPointerDownPointerX = event.clientX;
            onPointerDownPointerY = event.clientY;
            onPointerDownLon = lon;
            onPointerDownLat = lat;
        }, false );
        container.addEventListener( 'mousemove', function(event) {
            if ( isUserInteracting === true ) {
                lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
                lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
            }
        }, false );
        container.addEventListener( 'mouseup', function(event) {
            isUserInteracting = false;
        }, false );
        container.addEventListener( 'wheel', function(event) {
            camera.fov += event.deltaY * 0.05;
            camera.updateProjectionMatrix();
        }, false );

    }, false);



</script>

</body>
</html>
